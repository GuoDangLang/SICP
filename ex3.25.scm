(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup keys)
      (define (iter remain-keys records)
	(if (null? remain-keys) (cdr records)
	  (if (null? records) false
	    (let ((record (assoc (car remain-keys) (cdr records))))
	      (if record
	      (iter (cdr remain-keys) (assoc (car remain-keys) (cdr records)))
	      false)))))
      (iter keys local-table))
    (define (insert! keys value)
      (define (iter-insert remain-keys records)
	(define (keep-insert keys)
		(if (null? (cdr keys)) (cons (car keys) value)
		  (list (car keys) (keep-insert (cdr keys)))))
	(if (null? remain-keys) (if (not (null? records))
				  (set-cdr! records value)
				  (error "wrong"))
	  (let ((record (assoc (car remain-keys) (cdr records))))
	    (if record
	      (iter-insert (cdr remain-keys) record)
	      ;;;(define (keep-insert keys)
		;;;(if (null? (cdr keys)) (cons (car keys) value)
		  ;;;(list (car keys) (keep-insert (cdr keys)))))
	      (set-cdr! records (cons (keep-insert remain-keys) (cdr records)))))))
      (iter-insert keys local-table)
      'ok)
    ;;;keep the blank for the print-table, now i don't want to write that procedure;
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
	    ((eq? m 'insert!) insert!)
	    (else (error "Unkown-- FUck you!" m))))
    dispatch))
(define ndim (make-table))
(define get (ndim 'lookup))
(define put (ndim 'insert!))
	    
