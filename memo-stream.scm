(define the-empty-stream '())
(define (memo-proc proc)
  (let ((already-run? false)
	(result false))
      (delay (if (not already-run?)
	(begin (set! result (force proc))
	       (set! already-run? true)
	       result)
	result))))
(define (new-delay x) (memo-proc (delay x)))
(define (stream-car stream)
  (car stream))
(define stream-null? null?)
(define (stream-cdr stream)
  (force (cdr stream)))
(define (stream-ref s n)
  (if (= n 0)
    (stream-car s)
    (stream-ref (stream-cdr s) (- n 1))))
(define (stream-map proc s)
  (if (stream-null? s)
    the-empty-stream
    (cons (proc (stream-car s))
		 (new-delay (stream-map proc (stream-cdr s))))))
(define (stream-for-each proc s)
  (if (stream-null? s)
    'done
    (begin (proc (stream-car s))
	   (stream-for-each proc (stream-cdr s)))))
(define (display-stream s)
  (stream-for-each display-line s))
(define (display-line x)
  (newline)
  (display x))
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
	((pred (stream-car stream))
	 (cons (stream-car stream)
	       (new-delay (stream-filter pred (stream-cdr stream)))))
	(else (stream-filter pred (stream-cdr stream)))))
(define (stream-enumerate-interval a b)
  (if (> a b)
    the-empty-stream
    (cons  a (new-delay (stream-enumerate-interval (+ a 1) b)))))
;;; ex3.50
;;;(define (stream-map proc . argstreams)
;;;(if (stream-null? argstreams)
;;;the-empty-stream
;;;(cons-stream
;;;   (apply proc (map stream-car argstreams))
;;;   (apply stream-map
;;;   (cons proc (map stream-cdr argstreams))))))
;;; ex3.51
(define (show x)
  (display-line x)
  x)
(define x (stream-map show (stream-enumerate-interval 0 10)))
